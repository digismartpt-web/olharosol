---
---

<section id="reservas" class="py-20 bg-gray-50 text-gray-900 relative">
  <div class="container mx-auto px-4 relative z-10">
    <div class="text-center mb-12">
      <span class="text-primary uppercase tracking-wider text-sm font-semibold">Reservas Online</span>
      <h2 class="text-3xl md:text-4xl font-bold mt-2 mb-4 text-gray-900">Reserve a sua Mesa</h2>

    </div>

    <div class="max-w-4xl mx-auto bg-white rounded-2xl shadow-2xl overflow-hidden flex flex-col md:flex-row">
      <!-- Info Panel (G) -->
      <div class="bg-gray-900 p-8 md:w-1/3 text-white flex flex-col justify-between">
        <div>
          <h3 class="text-xl font-bold mb-6 text-primary">Informações</h3>
          <ul class="space-y-4 text-sm text-gray-300">
            <li class="flex items-start gap-3">
              <svg class="w-5 h-5 text-primary mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
              <div>
                <strong class="block text-white">Horário</strong>
                Almoço: 12h - 15h<br/>
                Jantar: 19h - 22h<br/>
                <span class="text-red-400">Fechado: Dom / Seg</span>
              </div>
            </li>
            <li class="flex items-start gap-3">
              <svg class="w-5 h-5 text-primary mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" /></svg>
              <div>
                <strong class="block text-white">Telefone</strong>
                252 996 426
                <p class="text-[10px] text-gray-400 mt-2 leading-tight">
                  * Apenas são tolerados 15 minutos de atraso. Após esse período, a reserva será cancelada automaticamente.
                </p>
              </div>
            </li>
          </ul>
        </div>
        <div class="mt-8 text-xs text-gray-500">
          * Para grupos > 10 pessoas, por favor contacte-nos por telefone.
        </div>
      </div>

      <!-- Form Panel (D) -->
      <div class="p-8 md:w-2/3 bg-white text-gray-800 relative">
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="absolute inset-0 bg-white/80 backdrop-blur-sm z-50 hidden flex items-center justify-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
        </div>

        <form id="reservation-form" class="space-y-6">
          <!-- Step 1: Details -->
          <div class="grid md:grid-cols-2 gap-6">
            <div>
              <label class="block text-sm font-semibold text-gray-700 mb-2">Data</label>
              <input 
                type="date" 
                id="res-date"
                required
                class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none transition-all"
              />
              <p class="text-xs text-red-500 mt-1 hidden" id="date-error">O restaurante encontra-se encerrado. Não é possível efetuar reservas.</p>
            </div>
            <div>
              <label class="block text-sm font-semibold text-gray-700 mb-2">Pessoas</label>
              <select id="res-guests" class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none transition-all">
                {[2, 3, 4, 5, 6, 7, 8].map(n => <option value={n}>{n} Pessoas</option>)}
              </select>
            </div>
          </div>

          <!-- Step 2: Time Slots (Dynamic) -->
          <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">Horário</label>
            <div id="slots-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
              <!-- Slots injected via JS -->
              <div class="col-span-4 text-gray-400 text-sm italic p-2 border border-dashed rounded text-center">
                Selecione uma data para ver disponibilidade
              </div>
            </div>
            <input type="hidden" id="res-time" required />
          </div>

          <!-- Step 3: Contact Info (Hidden until slot selected) -->
          <div id="contact-step" class="space-y-4 hidden opacity-0 transition-opacity duration-500">
            <div class="border-t border-gray-100 pt-6">
              <h4 class="text-sm uppercase tracking-wide text-primary font-bold mb-4">Seus Dados</h4>
              <div>
                <label class="block text-sm font-semibold text-gray-700 mb-2">Nome Completo</label>
                <input 
                  type="text" 
                  id="res-name"
                  required
                  placeholder="Seu nome"
                  class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none transition-all"
                />
              </div>
              <div class="grid md:grid-cols-2 gap-6 mt-4">
                <div>
                  <label class="block text-sm font-semibold text-gray-700 mb-2">Email</label>
                  <input 
                    type="email" 
                    id="res-email"
                    required
                    placeholder="seu@email.com"
                    class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none transition-all"
                  />
                </div>
                <div>
                  <label class="block text-sm font-semibold text-gray-700 mb-2">Telefone</label>
                  <input 
                    type="tel" 
                    id="res-phone"
                    required
                    placeholder="912 345 678"
                    class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none transition-all"
                  />
                </div>
              </div>
            </div>

            <!-- Submit -->
            <button 
              type="submit" 
              class="w-full bg-primary hover:bg-secondary text-white font-bold py-4 rounded-xl shadow-lg hover:shadow-xl transform hover:-translate-y-0.5 transition-all duration-300"
            >
              Confirmar Reserva
            </button>
          </div>
        </form>

        <!-- Success Message (Hidden) -->
          <div id="success-message" class="hidden text-center py-10">
            <div class="w-16 h-16 bg-green-100 text-green-500 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>
            </div>
            <h3 class="text-2xl font-bold text-gray-900 mb-2">Reserva Confirmada!</h3>
            <p class="text-gray-600 mb-6 font-medium">
              Obrigado pela sua preferência.
            </p>
          <button id="reset-form" class="text-primary font-semibold hover:underline">Fazer nova reserva</button>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  .pattern-dots {
    background-image: radial-gradient(#ffffff 2px, transparent 2px);
    background-size: 30px 30px;
  }
</style>

<script>
  import { db } from "../lib/firebase.js";
  import { collection, addDoc, query, where, getDocs, doc, onSnapshot } from "firebase/firestore";

  const form = document.getElementById('reservation-form');
  const dateInput = document.getElementById('res-date') as HTMLInputElement;
  const timeInput = document.getElementById('res-time') as HTMLInputElement;
  const slotsContainer = document.getElementById('slots-container');
  const contactStep = document.getElementById('contact-step');
  const dateError = document.getElementById('date-error');
  const successMessage = document.getElementById('success-message');
  const resetButton = document.getElementById('reset-form');
  const loadingOverlay = document.getElementById('loading-overlay');
  const guestSelect = document.getElementById('res-guests') as HTMLSelectElement;

  // CONFIG & STATE
  const SLOT_INTERVAL = 30; // minutes
  let currentSettings = {
      closedDays: [0, 1],
      maxGuests: 8,
      minAdvance: 30, // minutes
      resDuration: 60, // minutes (new)
      vacationStart: null,
      vacationEnd: null,
      lunch: { start: 12, end: 15 },
      dinner: { start: 19, end: 22 },
      tables: [] // [{ id, name, capacity, combinable }]
  };

  // 1. REAL-TIME SETTINGS LISTENER
  const settingsDoc = doc(db, "settings", "general");
  onSnapshot(settingsDoc, (snap) => {
      if (snap.exists()) {
          const s = snap.data();
          
          if (s.closedDays) currentSettings.closedDays = s.closedDays;
          if (s.maxGuests) currentSettings.maxGuests = s.maxGuests;
          if (s.minAdvance !== undefined) currentSettings.minAdvance = s.minAdvance;
          if (s.resDuration !== undefined) currentSettings.resDuration = s.resDuration;
          currentSettings.vacationStart = s.vacationStart || null;
          currentSettings.vacationEnd = s.vacationEnd || null;

          if (s.lunchStart) currentSettings.lunch.start = s.lunchStart;
          if (s.lunchEnd) currentSettings.lunch.end = s.lunchEnd;
          if (s.dinnerStart) currentSettings.dinner.start = s.dinnerStart;
          if (s.dinnerEnd) currentSettings.dinner.end = s.dinnerEnd;
          
          currentSettings.tables = s.tables || [];

          // Update UI: Guests Dropdown
          updateGuestSelect();

          // Update UI: Slots (if date selected)
          if (dateInput.value) {
              refreshAvailability(dateInput.value);
          }
      }
  });

  function updateGuestSelect() {
      const currentVal = parseInt(guestSelect.value) || 2;
      guestSelect.innerHTML = '';
      for (let i = 1; i <= currentSettings.maxGuests; i++) {
          const option = document.createElement('option');
          option.value = i.toString();
          option.textContent = i + (i === 1 ? " Pessoa" : " Pessoas");
          guestSelect.appendChild(option);
      }
      const newVal = Math.min(currentVal, currentSettings.maxGuests);
      guestSelect.value = newVal > 0 ? newVal.toString() : "1";
  }

  // HELPER: Check if guests can be accommodated (single table or combination)
  function canAccommodateGuests(guestCount, availableTables) {
      // 1. Try single table first (best case)
      const singleTable = availableTables.find(t => t.capacity >= guestCount);
      if (singleTable) return true;
      
      // 2. Filter combinable tables for combinations
      const combinableTables = availableTables.filter(t => t.combinable !== false);
      
      // 3. Try combining 2 tables
      for (let i = 0; i < combinableTables.length; i++) {
          for (let j = i + 1; j < combinableTables.length; j++) {
              const combinedCapacity = combinableTables[i].capacity + combinableTables[j].capacity;
              if (combinedCapacity >= guestCount) return true;
          }
      }
      
      // 4. Try combining 3 tables (rare but possible)
      if (combinableTables.length >= 3) {
          for (let i = 0; i < combinableTables.length; i++) {
              for (let j = i + 1; j < combinableTables.length; j++) {
                  for (let k = j + 1; k < combinableTables.length; k++) {
                      const combinedCapacity = combinableTables[i].capacity + combinableTables[j].capacity + combinableTables[k].capacity;
                      if (combinedCapacity >= guestCount) return true;
                  }
              }
          }
      }
      
      return false; // No solution found
  }

  // HELPER: Find best table solution (returns { tables: [...], totalCapacity: X })
  function findBestTableSolution(guestCount, availableTables) {
      // 1. Try single table first (prefer smallest that fits)
      const singleTables = availableTables
          .filter(t => t.capacity >= guestCount)
          .sort((a, b) => a.capacity - b.capacity);
      
      if (singleTables.length > 0) {
          return { tables: [singleTables[0]], totalCapacity: singleTables[0].capacity };
      }
      
      // Filter combinable tables for combinations
      const combinableTables = availableTables.filter(t => t.combinable !== false);
      
      // 2. Try combining 2 tables (prefer smallest total capacity)
      let bestPair = null;
      let bestPairCapacity = Infinity;
      
      for (let i = 0; i < combinableTables.length; i++) {
          for (let j = i + 1; j < combinableTables.length; j++) {
              const combinedCapacity = combinableTables[i].capacity + combinableTables[j].capacity;
              if (combinedCapacity >= guestCount && combinedCapacity < bestPairCapacity) {
                  bestPair = [combinableTables[i], combinableTables[j]];
                  bestPairCapacity = combinedCapacity;
              }
          }
      }
      
      if (bestPair) {
          return { tables: bestPair, totalCapacity: bestPairCapacity };
      }
      
      // 3. Try combining 3 tables
      let bestTrio = null;
      let bestTrioCapacity = Infinity;
      
      if (combinableTables.length >= 3) {
          for (let i = 0; i < combinableTables.length; i++) {
              for (let j = i + 1; j < combinableTables.length; j++) {
                  for (let k = j + 1; k < combinableTables.length; k++) {
                      const combinedCapacity = combinableTables[i].capacity + combinableTables[j].capacity + combinableTables[k].capacity;
                      if (combinedCapacity >= guestCount && combinedCapacity < bestTrioCapacity) {
                          bestTrio = [combinableTables[i], combinableTables[j], combinableTables[k]];
                          bestTrioCapacity = combinedCapacity;
                      }
                  }
              }
          }
      }
      
      if (bestTrio) {
          return { tables: bestTrio, totalCapacity: bestTrioCapacity };
      }
      
      return null; // No solution found
  }

  // 2. HELPER: Generate time slots
  function generateSlots(service) {
    const slots = [];
    let current = service.start * 60; 
    const end = service.end * 60;
    
    while (current < end) {
      const h = Math.floor(current / 60);
      const m = current % 60;
      const timeString = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
      slots.push(timeString);
      current += SLOT_INTERVAL;
    }
    return slots;
  }

  // 3. MAIN LOGIC: Date Change
  dateInput.min = new Date().toISOString().split('T')[0];
  
  dateInput.addEventListener('change', (e) => {
      refreshAvailability((e.target as HTMLInputElement).value);
  });

  guestSelect.addEventListener('change', () => {
      if (dateInput.value) {
          refreshAvailability(dateInput.value);
      }
  });

  async function refreshAvailability(dateStr) {
      if (!dateStr) return;

      const date = new Date(dateStr);
      const day = date.getDay(); // 0 = Sun

      // Reset UI
      slotsContainer.innerHTML = '<div class="col-span-4 text-center py-2"><span class="animate-pulse text-primary">Verificando disponibilidade...</span></div>';
      timeInput.value = '';
      contactStep.classList.add('hidden');
      dateError.classList.add('hidden');

      // 1. Check Closed Days
      if (currentSettings.closedDays.includes(day)) {
          showError("O restaurante encontra-se encerrado. Não é possível efetuar reservas.");
          return;
      }

      // 2. Check Vacation
      if (currentSettings.vacationStart && currentSettings.vacationEnd) {
          const start = new Date(currentSettings.vacationStart);
          const end = new Date(currentSettings.vacationEnd);
          start.setHours(0,0,0,0);
          end.setHours(23,59,59,999);
          const selected = new Date(dateStr);
          selected.setHours(12,0,0,0);

          if (selected >= start && selected <= end) {
              showError("Estamos encerrados para férias neste período.");
              return;
          }
      }

      // 3. Fetch Existing Reservations
      let takenSlots = [];
      try {
          const q = query(collection(db, "reservations"), where("date", "==", dateStr));
          const querySnapshot = await getDocs(q);
          querySnapshot.forEach((doc) => {
              const data = doc.data();
              // Store full reservation object for Advanced mode (needs assignedTable)
              takenSlots.push({
                  time: data.time,
                  assignedTable: data.assignedTable || null
              });
          });
      } catch (err) {
          console.error("Error fetching availability:", err);
      }

      // 4. PRE-CHECK: Tables configuration
      if (!currentSettings.tables || currentSettings.tables.length === 0) {
          slotsContainer.innerHTML = '<div class="col-span-4 text-center text-red-500 bg-red-50 p-4 rounded-lg border border-red-100 text-sm">O restaurante ainda não configurou as mesas. Por favor, tente mais tarde.</div>';
          return;
      }

      // 5. Generate & Render Slots
      slotsContainer.innerHTML = '';
      const lunchSlots = generateSlots(currentSettings.lunch);
      const dinnerSlots = generateSlots(currentSettings.dinner);
      const allSlots = [...lunchSlots, ...dinnerSlots];

      if (allSlots.length === 0) {
           slotsContainer.innerHTML = '<div class="col-span-4 text-center text-gray-500 py-2">Não há horários disponíveis para hoje.</div>';
           return;
      }

      allSlots.forEach(time => {
          const slotBtn = document.createElement('button');
          slotBtn.type = 'button';
          slotBtn.className = 'py-3 px-2 rounded-xl border text-sm font-medium transition-all hover:border-primary hover:bg-primary/5 active:scale-95 touch-manipulation';
          slotBtn.textContent = time;

          // Check if slot is in the past or too close (for same-day reservations)
          const [h, m] = time.split(':').map(Number);
          const slotDateTime = new Date(dateStr);
          slotDateTime.setHours(h, m, 0, 0);
          
          const now = new Date();
          const minAdvanceMs = currentSettings.minAdvance * 60 * 1000; // Convert minutes to milliseconds
          const isTooClosed = slotDateTime.getTime() - now.getTime() < minAdvanceMs;

          if (isTooClosed) {
              slotBtn.disabled = true;
              slotBtn.classList.add('bg-gray-100', 'text-gray-400', 'cursor-not-allowed', 'line-through');
              slotBtn.title = "Horário já passou ou muito próximo";
          } else {
              // ADVANCED CAPACITY LOGIC (with Duration support)
              const guestCount = parseInt(guestSelect.value);
              const currentSlotMin = h * 60 + m;
              const duration = currentSettings.resDuration || 60;
              
              const occupiedTableIds = [];
              takenSlots.forEach(res => {
                  if (res.assignedTable) {
                      const [extH, extM] = res.time.split(':').map(Number);
                      const extStartMin = extH * 60 + extM;
                      const extEndMin = extStartMin + duration;
                      
                      const newStartMin = currentSlotMin;
                      const newEndMin = newStartMin + duration;

                      // OVERLAP CHECK: (Start1 < End2) && (Start2 < End1)
                      if (extStartMin < newEndMin && newStartMin < extEndMin) {
                          const tableIds = res.assignedTable.split('+');
                          occupiedTableIds.push(...tableIds);
                      }
                  }
              });
              
              // Get available tables
              const availableTables = currentSettings.tables.filter(table => 
                  !occupiedTableIds.includes(table.id)
              );
              
              // Try to find a solution (single table or combination)
              const isAvailable = canAccommodateGuests(guestCount, availableTables);

              if (!isAvailable) {
                  slotBtn.disabled = true;
                  slotBtn.classList.add('bg-gray-100', 'text-gray-400', 'cursor-not-allowed', 'line-through');
                  slotBtn.title = "Esgotado";
              } else {
                  slotBtn.onclick = () => selectSlot(slotBtn, time);
              }
          }

          slotsContainer.appendChild(slotBtn);
      });
  }

  function showError(msg) {
      slotsContainer.innerHTML = '';
      dateError.textContent = msg;
      dateError.classList.remove('hidden');
      dateInput.value = '';
  }

  function selectSlot(btn, time) {
    Array.from(slotsContainer.children).forEach((b: any) => {
        if (!b.disabled) b.className = 'py-3 px-2 rounded-xl border text-sm font-medium transition-all hover:border-primary hover:bg-primary/5 active:scale-95 touch-manipulation';
    });
    btn.className = 'py-3 px-2 rounded-xl border bg-primary text-white border-primary shadow-md transform scale-105 z-10';
    timeInput.value = time;
    contactStep.classList.remove('hidden');
    setTimeout(() => {
        contactStep.classList.add('opacity-100');
        contactStep.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }, 50);

  // SUBMIT
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!timeInput.value) { alert('Por favor selecione um horário'); return; }
    loadingOverlay.classList.remove('hidden');

    try {
        const formData: any = {
            date: dateInput.value,
            time: timeInput.value,
            guests: parseInt(guestSelect.value) || 2,
            name: (document.getElementById('res-name') as HTMLInputElement).value,
            email: (document.getElementById('res-email') as HTMLInputElement).value,
            phone: (document.getElementById('res-phone') as HTMLInputElement).value,
            createdAt: new Date(),
            to: [(document.getElementById('res-email') as HTMLInputElement).value], 
            cc: ['restaurantedomhenrique@iol.pt'], 
            message: {
                subject: `Reserva Confirmada - Dom Henrique (${dateInput.value})`,
                html: `
                    <div style="font-family: sans-serif; color: #333;">
                        <h2 style="color: #b91c1c;">Reserva Confirmada</h2>
                        <p>Olá <strong>${(document.getElementById('res-name') as HTMLInputElement).value}</strong>,</p>
                        <p>A sua reserva no <strong>Restaurante Dom Henrique</strong> foi registada com sucesso.</p>
                        <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">
                        <ul>
                            <li><strong>Data:</strong> ${dateInput.value}</li>
                            <li><strong>Hora:</strong> ${timeInput.value}</li>
                            <li><strong>Pessoas:</strong> ${guestSelect.value}</li>
                        </ul>
                        <p>Se precisar de cancelar, por favor contacte-nos por telefone: 252 996 426.</p>
                        <p><em>Obrigado pela preferência!</em></p>
                    </div>
                `
            }
        };
        
        if (currentSettings.tables && currentSettings.tables.length > 0) {
            const guestCount = parseInt(guestSelect.value);
            const selectedTime = timeInput.value;
            const [newH, newM] = selectedTime.split(':').map(Number);
            const newStartMin = newH * 60 + newM;
            const duration = currentSettings.resDuration || 60;
            const newEndMin = newStartMin + duration;
            
            // 1. Fetch ALL reservations for this date to check overlap
            const q = query(
                collection(db, "reservations"), 
                where("date", "==", dateInput.value)
            );
            const snapshot = await getDocs(q);
            const occupiedTableIds = [];
            
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.assignedTable) {
                    const [extH, extM] = data.time.split(':').map(Number);
                    const extStartMin = extH * 60 + extM;
                    const extEndMin = extStartMin + duration;
                    
                    // Overlap condition: (Start1 < End2) && (Start2 < End1)
                    if (extStartMin < newEndMin && newStartMin < extEndMin) {
                        const tableIds = data.assignedTable.split('+');
                        occupiedTableIds.push(...tableIds);
                    }
                }
            });
            
            // 2. Find best solution (single table or combination)
            const allAvailableTables = currentSettings.tables.filter(t => !occupiedTableIds.includes(t.id));
            const solution = findBestTableSolution(guestCount, allAvailableTables);
            
            if (!solution) {
                alert('Desculpe, não há mesas disponíveis para este período. Por favor escolha outro horário.');
                loadingOverlay.classList.add('hidden');
                return;
            }
            
            // 3. Assign table(s)
            if (solution.tables.length === 1) {
                formData.assignedTable = solution.tables[0].id;
                formData.assignedTableName = solution.tables[0].name;
            } else {
                formData.assignedTable = solution.tables.map(t => t.id).join('+');
                formData.assignedTableName = solution.tables.map(t => t.name).join(' + ');
            }
        }

        await addDoc(collection(db, "reservations"), formData);
        form.classList.add('hidden');
        successMessage.classList.remove('hidden');

    } catch (err: any) {
        console.error("Error writing document: ", err);
        const errorDetails = err && typeof err === 'object' ? JSON.stringify(err) : String(err);
        const errorMessage = (err && err.message) || String(err);
        const errorCode = (err && err.code) || 'unknown';
        
        alert(`Ocorreu um erro ao registar a reserva.\n\nDetalhes: ${errorMessage}\nCódigo: ${errorCode}\n\nPor favor, tire uma captura de ecrã deste erro.`);
    } finally {
        loadingOverlay.classList.add('hidden');
    }
  });

  resetButton.addEventListener('click', () => {
    form.reset();
    slotsContainer.innerHTML = '<div class="col-span-4 text-gray-400 text-sm italic p-2 border border-dashed rounded text-center">Selecione uma data para ver disponibilidade</div>';
    timeInput.value = '';
    contactStep.classList.add('hidden', 'opacity-0');
    form.classList.remove('hidden');
    successMessage.classList.add('hidden');
  });

</script>
